import * as FileSystem from 'expo-file-system'
import { supabase } from '../supabaseClient'
import { SUPABASE_URL } from '../../../config'
import * as ImagePicker from 'expo-image-picker'

// Types for message attachments
export type MessageAttachment = {
  id?: string // Optional when creating, auto-generated by database
  message_id?: string // Optional when creating, required when stored
  url: string
  type: 'image' | 'video' | 'file'
  created_at: string
}

export type MessageWithAttachments = {
  id: string
  sender_id: string
  recipient_id: string
  content: string
  created_at: string
  read_at?: string
  attachments?: MessageAttachment[]
}

/**
 * Fetch all messages between two users (in chronological order) with attachments.
 */
export async function fetchMessagesBetween(userId: string, otherUserId: string): Promise<MessageWithAttachments[]> {
  const { data: messages, error } = await supabase
    .from('messages')
    .select('*')
    .in('sender_id', [userId, otherUserId])
    .in('recipient_id', [userId, otherUserId])
    .order('created_at', { ascending: true })
    .not('id', 'is', null)

  if (error) {
    console.error('❌ Failed to fetch messages:', error)
    return []
  }

  // Fetch attachments for all messages
  const messageIds = messages?.map(msg => msg.id) || []
  
  if (messageIds.length === 0) return messages || []

  const { data: attachments, error: attachmentsError } = await supabase
    .from('message_attachments')
    .select('*')
    .in('message_id', messageIds)
    .order('created_at', { ascending: true })

  if (attachmentsError) {
    console.error('❌ Failed to fetch attachments:', attachmentsError)
    return messages || []
  }

  // Group attachments by message_id
  const attachmentsByMessage = (attachments || []).reduce((acc, attachment) => {
    if (!acc[attachment.message_id]) {
      acc[attachment.message_id] = []
    }
    acc[attachment.message_id].push(attachment)
    return acc
  }, {} as Record<string, MessageAttachment[]>)

  // Combine messages with their attachments
  return (messages || []).map(message => ({
    ...message,
    attachments: attachmentsByMessage[message.id] || []
  }))
}

/**
 * Send a message from one user to another with optional attachments.
 */
export async function sendMessage(
  senderId: string, 
  recipientId: string, 
  content: string, 
  attachments?: MessageAttachment[]
) {
  const { data: message, error: messageError } = await supabase
    .from('messages')
    .insert({
      sender_id: senderId,
      recipient_id: recipientId,
      content,
    })
    .select()
    .single()

  if (messageError) {
    console.error('❌ Failed to send message:', messageError)
    return null
  }

  // Insert attachments if provided
  if (attachments && attachments.length > 0) {
    const attachmentsWithMessageId = attachments.map(attachment => ({
      message_id: message.id,
      url: attachment.url,
      type: attachment.type,
      created_at: attachment.created_at
    }))

    const { data: insertedAttachments, error: attachmentsError } = await supabase
      .from('message_attachments')
      .insert(attachmentsWithMessageId)
      .select()

    if (attachmentsError) {
      console.error('❌ Failed to insert attachments:', attachmentsError)
    }
  }

  return message
}

/**
 * Upload image to Supabase Storage and return attachment metadata.
 */
export async function uploadImageAttachment(
  imageUri: string,
  messageId: string
): Promise<MessageAttachment | null> {
  try {

    const timestamp = Date.now()
    const extensionMatch = imageUri.match(/\.(\w+)$/)
    const fileExtension = extensionMatch?.[1] ?? 'jpg'
    const uniqueFileName = `${timestamp}_${Math.random().toString(36).substring(7)}.${fileExtension}`
    const path = `${messageId}/${uniqueFileName}`

    const session = await supabase.auth.getSession()
    const accessToken = session.data.session?.access_token
    if (!accessToken) throw new Error('Missing access token')

    const uploadUrl = `${SUPABASE_URL}/storage/v1/object/message-attachments/${path}`

    const uploadResponse = await FileSystem.uploadAsync(uploadUrl, imageUri, {
      httpMethod: 'PUT',
      headers: {
        Authorization: `Bearer ${accessToken}`,
        'Content-Type': `image/${fileExtension}`,
        'Cache-Control': '3600',
      },
    })

    if (uploadResponse.status !== 200) {
      throw new Error(`Upload failed with status ${uploadResponse.status}: ${uploadResponse.body}`)
    }

    const { data: urlData } = supabase.storage
      .from('message-attachments')
      .getPublicUrl(path)

    // Clean the URL to avoid duplicate query parameters
    const cleanUrl = urlData.publicUrl.split('?')[0]

    return {
      message_id: messageId || undefined,
      url: cleanUrl,
      type: 'image' as const,
      created_at: new Date().toISOString(),
    }
  } catch (error) {
    console.error('❌ Error uploading image:', error)
    return null
  }
}

/**
 * Pick image from device gallery or camera.
 */
export async function pickImage(): Promise<string | string[] | null> {
  try {
    // Request permissions
    const permissionResult = await ImagePicker.requestMediaLibraryPermissionsAsync()
    
    if (permissionResult.granted === false) {
      console.log('❌ Permission to access camera roll is required!')
      return null
    }

    // Launch image picker
    const result = await ImagePicker.launchImageLibraryAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: false,
      quality: 0.8,
      allowsMultipleSelection: true,
    })

    if (!result.canceled && result.assets && result.assets.length > 0) {
      // Return array of URIs if multiple images selected, single URI if one image
      const uris = result.assets.map(asset => asset.uri)
      return uris.length === 1 ? uris[0] : uris
    }

    return null
  } catch (error) {
    console.error('❌ Error picking image:', error)
    return null
  }
}

/**
 * Take photo with camera.
 */
export async function takePhoto(): Promise<string | null> {
  try {
    // Request permissions
    const permissionResult = await ImagePicker.requestCameraPermissionsAsync()
    
    if (permissionResult.granted === false) {
      console.log('❌ Permission to access camera is required!')
      return null
    }

    // Launch camera
    const result = await ImagePicker.launchCameraAsync({
      mediaTypes: ImagePicker.MediaTypeOptions.Images,
      allowsEditing: false,
      quality: 0.8,
    })

    if (!result.canceled && result.assets && result.assets.length > 0) {
      return result.assets[0].uri
    }

    return null
  } catch (error) {
    console.error('❌ Error taking photo:', error)
    return null
  }
}

/**
 * Test if an image URL is accessible
 */
export async function testImageUrl(url: string): Promise<boolean> {
  try {
    const response = await fetch(url, { method: 'HEAD' })
    return response.ok
  } catch (error) {
    console.error('❌ Error testing image URL:', url, error)
    return false
  }
}

/**
 * Test if the storage bucket exists and is accessible
 */
export async function testStorageBucket(): Promise<boolean> {
  try {
    const { data, error } = await supabase.storage
      .from('message-attachments')
      .list('', { limit: 1 })
    
    if (error) {
      console.error('❌ Storage bucket error:', error)
      return false
    }
    
    return true
  } catch (error) {
    console.error('❌ Error testing storage bucket:', error)
    return false
  }
}

/**
 * Test function to check if message_attachments table exists and is accessible.
 */
export async function testAttachmentsTable(): Promise<boolean> {
  try {
    // First, let's see what columns exist in the table
    const { data: columns, error: columnsError } = await supabase
      .from('message_attachments')
      .select('*')
      .limit(0)
    
    if (columnsError) {
      console.error('❌ message_attachments table error:', columnsError)
      console.error('❌ This likely means the table doesn\'t exist or has wrong structure')
      console.error('❌ Please run the SQL script in create_message_attachments_table.sql')
      return false
    }
    
    return true
  } catch (error) {
    console.error('❌ Error testing message_attachments table:', error)
    return false
  }
}

/**
 * Delete attachment from storage and database.
 */
export async function deleteAttachment(attachmentId: string, fileUrl: string): Promise<boolean> {
  try {
    // Extract filename from URL
    const fileName = fileUrl.split('/').pop()
    
    if (fileName) {
      // Delete from storage
      const { error: storageError } = await supabase.storage
        .from('message-attachments')
        .remove([fileName])

      if (storageError) {
        console.error('❌ Failed to delete from storage:', storageError)
      }
    }

    // Delete from database
    const { error: dbError } = await supabase
      .from('message_attachments')
      .delete()
      .eq('id', attachmentId)

    if (dbError) {
      console.error('❌ Failed to delete from database:', dbError)
      return false
    }

    return true
  } catch (error) {
    console.error('❌ Error deleting attachment:', error)
    return false
  }
}

/**
 * Fetch the latest message per conversation for the inbox view.
 * Requires the `get_latest_messages_for_user` function in Supabase.
 */
export async function fetchLatestMessagesForUser(userId: string) {
    const { data, error } = await supabase
      .from('messages')
      .select('*')
      .or(`sender_id.eq.${userId},recipient_id.eq.${userId}`)
      .order('created_at', { ascending: false })
  
    if (error || !data) {
      console.error('❌ Failed to fetch messages:', error)
      return []
    }
  
    // Deduplicate to latest message per conversation
    const seen = new Map<string, any>()
    for (const message of data) {
      const otherUserId =
        message.sender_id === userId ? message.recipient_id : message.sender_id
      if (!seen.has(otherUserId)) seen.set(otherUserId, message)
    }
  
    const latestMessages = Array.from(seen.values())
  
    // Get unread message counts for each conversation
    const unreadCounts = await getUnreadMessageCounts(userId)
  
    // Collect unique user IDs to look up
    const userIds = Array.from(
      new Set(
        latestMessages.flatMap((msg) => [msg.sender_id, msg.recipient_id])
      )
    )
  
    const { data: users, error: userError } = await supabase
      .from('users')
      .select('id, first_name, last_name, profile_url')
      .in('id', userIds)
  
    if (userError || !users) {
      console.error('❌ Failed to fetch user profiles:', userError)
      return latestMessages
    }
  
    const userMap = Object.fromEntries(users.map((u) => [u.id, u]))
  
    // Fetch attachments for latest messages
    const messageIds = latestMessages.map(msg => msg.id)
    const { data: attachments, error: attachmentsError } = await supabase
      .from('message_attachments')
      .select('*')
      .in('message_id', messageIds)
      .order('created_at', { ascending: true })

    if (attachmentsError) {
      console.error('❌ Failed to fetch attachments:', attachmentsError)
    }

    // Group attachments by message_id
    const attachmentsByMessage = (attachments || []).reduce((acc, attachment) => {
      if (!acc[attachment.message_id]) {
        acc[attachment.message_id] = []
      }
      acc[attachment.message_id].push(attachment)
      return acc
    }, {} as Record<string, MessageAttachment[]>)
  
    return latestMessages.map((msg) => {
      const otherId = msg.sender_id === userId ? msg.recipient_id : msg.sender_id
      const otherUser = userMap[otherId]
      const unreadCount = unreadCounts[otherId] || 0
      const isUnread = msg.recipient_id === userId && !msg.read_at
      
      return {
        ...msg,
        first_name: otherUser?.first_name ?? 'Unknown',
        last_name: otherUser?.last_name ?? '',
        profile_url: otherUser?.profile_url ?? null,
        unread_count: unreadCount,
        is_unread: isUnread,
        attachments: attachmentsByMessage[msg.id] || [],
      }
    })
}

/**
 * Get unread message counts for a user
 */
export async function getUnreadMessageCounts(userId: string) {
  const { data, error } = await supabase
    .from('messages')
    .select('sender_id, recipient_id, read_at')
    .eq('recipient_id', userId)
    .is('read_at', null)

  if (error) {
    console.error('❌ Failed to fetch unread messages:', error)
    return {}
  }

  // Group by sender to get count per conversation
  const unreadCounts: { [senderId: string]: number } = {}
  data?.forEach(message => {
    const senderId = message.sender_id
    unreadCounts[senderId] = (unreadCounts[senderId] || 0) + 1
  })

  return unreadCounts
}

/**
 * Mark all unread incoming messages in a thread as read.
 * Only marks messages where `recipient_id === userId` and `sender_id === otherUserId`.
 */
export async function markIncomingMessagesAsRead(userId: string, otherUserId: string) {
    const { data: unreadMessages, error } = await supabase
      .from('messages')
      .select('id')
      .eq('recipient_id', userId)
      .eq('sender_id', otherUserId)
      .is('read_at', null)
  
    if (error) {
      console.error('❌ Failed to fetch unread messages:', error)
      return { success: false, error }
    }
  
    const unreadIds = unreadMessages?.map(m => m.id) || []
  
    if (unreadIds.length === 0) {
      return { success: true, updatedCount: 0 }
    }
  
    const { error: updateError } = await supabase
      .from('messages')
      .update({ read_at: new Date().toISOString() })
      .in('id', unreadIds)
  
    if (updateError) {
      console.error('❌ Failed to mark messages as read:', updateError)
      return { success: false, error: updateError }
    }
  
    return { success: true, updatedCount: unreadIds.length }
  }